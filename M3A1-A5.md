#### **Άσκηση 1:**



**Κώδικας C:**

\#include <stdio.h>

\#include <stdlib.h>



void replace(int arr\[],int n, int key,int value)

{

&nbsp;   for (int i=0;i<n;i++)

&nbsp;   {

&nbsp;       if(arr\[i]==key)

&nbsp;       {

&nbsp;           arr\[i]=value;

&nbsp;       }

&nbsp;   }

}



int main()

{

&nbsp;   int arr\[]={5,4,5,5,2};

&nbsp;   int n=5;

&nbsp;   

&nbsp;   replace (arr,5,5,3);

&nbsp;   

&nbsp;   printf("arr={");

&nbsp;   

&nbsp;       for(int i=0;i<n;i++)

&nbsp;           printf("%d,",arr\[i]);

&nbsp;           

&nbsp;   printf("}");

&nbsp;   

&nbsp;   return 0;

&nbsp;   

}



α)

&nbsp;	Η εντολή replace για συγκεκριμένες μεταβλητές συγκρίνει τις τιμές του πίνακα arr\[], μια την φορά n φορές συνολικά με μια συγκεκριμένη τιμή "κλειδί" (key). Σε όποια θέση του πίνακα βρει μετά από σύγκριση με την τιμή value ότι αυτές είναι ίσες, αντικαθιστά την πρώτη με την δοσμένη τιμή της μεταβλητής key. Στο συγκεκριμένο παράδειγμα, θα συγκριθούν όλες οι τιμές του πίνακα, όπου όταν η τιμή arr\[i] ισούται με 5, αυτή θα αντικαθίσταται με την τιμή 3 και όλο αυτό θα γίνει n=5 φορές. Συνεπώς, μόλις κληθεί η replace(arr,5,5,3), ο πίνακας arr θα γίνει arr\[]={3,4,3,3,2}.



β)

&nbsp;	Οι πράξεις που γίνονται συνολικά στην replace είναι οι εξής:

* ανάθεση i=0
* σύγκριση i με n, όπου i<n
* αύξηση το i κατά 1, με το i++
* σύγκριση arr\[i] με την key
* ανάθεση value στην arr\[i]



&nbsp;	Η πρώτη ανάθεση γίνεται 1 φορά. Η σύγκριση του i με το n γίνεται 6 φορές, στις 5 θα εκτελεστεί η for και στην 6η, όπου θα γίνει i=5, θα σταματήσει (αφού 5<5 άτοπο). Η αύξηση του i κατά 1 θα γίνει 5 φορές, με την 5η φορά να γίνεται i=5. Τέλος, στην if η σύγκριση arr\[i] με key θα γίνει 5 φορές, όσο είναι και το μήκος του n και η ανάθεση value στην arr\[i] θα γίνει 3 φορές. Συνεπώς, συνολικά θα πραγματοποιηθούν 20 πράξεις.



γ)

&nbsp;	Από το προηγούμενο ερώτημα προκύπτει ότι οι πράξεις εκτελούνται:

* ανάθεση i=0 1 φορά
* σύγκριση i με n, 6 φορές, άρα n+1
* αύξηση το i κατά 1, 5 φορές, άρα n
* σύγκριση arr\[i] με key, 5 φορές, άρα n
* ανάθεση value στην arr\[i], 3 φορές, αφού η τιμή "5" εμφανίζεται 3 φορές στον πίνακα. Έτσι, καταλήγουμε στο ότι η χειρότερη πολυπλοκότητα συναντάται όταν η ανάθεση γίνεται τόσες φορές όσες είναι και οι συγκρίσεις, άρα n.

&nbsp;	Επομένως, ισχύει ότι T(n)=1 + (n+1) + n + n + n = 4n-2 

&nbsp;	Επειδή θεωρούμε το n πολύ μεγάλο, το 2 διαγράφεται, όπως επίσης και το 4, επειδή είναι μια σταθερά. Συνεπώς έχουμε T(n)=O(n) χειρότερη πολυπλοκότητα.

#### **Άσκηση 2**

**Κώδικας C:**

for(int i=0;i<n;i++)

{

&nbsp;   for (int j=i+1;j<n-1;j++)

&nbsp;   {

&nbsp;       arr\[i] = arr\[j];

&nbsp;   }

}



&nbsp;	Στον κώδικα, η πράξη arr\[i] = arr\[j] εκτελείται n-i-2 φορές (n-1 από το πρώτο for πλην (i+1) που είναι η αρχική τιμή του j). Παρατηρούμε ότι όσο δίνουμε τιμές στο i, γίνεται το εξής:

i=0 -> n-2 φορές

i=1 -> n-3 φορές

i=2 -> n-4 φορές

………..…..….....

i=n-3 -> 1 φορά



Συνεπώς Το άθροισμα έχει την μορφή Σ(i=0...i=n-3)(n-i-2)=\[(n-2)+(n-3)+....1]/2=\[(n-2)\*(n-1)]/2 = n^2-3n-2=n^2



&nbsp;	Αυτό είναι ανεξάρτητο από τις φορές που θα εκτελεστεί ο κώδικας, καθώς σε κάθε περίπτωση για n>=1, θα προκύπτει ταυτότητα τετραγώνου, οπότε η χρονική πολυπλοκότητα θα είναι πάντα n^2



&nbsp;	Συνεπώς Best Case=Worst Case=Average Case=n^2 χρονική πολυπλοκότητα 



#### **Άσκηση 3**



&nbsp;	Για να δούμε για ποιο εύρος τιμών του n ο Β είναι καλύτερος από τον Α, αρκεί να ισχύει Β<Α=>n^3 - 4n < 2n^2 - 2n + 1 => n^3 - 2n^2 - 2n - 1 < 0 (1)

Βρίσκουμε τις ρίζες της (1)



Έχουμε υπόψη ότι n>1

για n=2 (1) => 8 - 8 - 4 - 1 < 0 => -5 < 0 που ισχύει

για n=3 (1) => 27 - 18 - 6 - 1 < 0 => 2 < 0 άτοπο



Άρα για n=2, ο Β είναι καλύτερος από τον Α



Για πολύ μεγάλο n, επιλέγω τον Α, διότι για τους χρόνους εκτέλεσης ισχύει το εξής:

TA(n)=2n^2

TB(n)=n^3

&nbsp;	για πολύ μεγάλο n ισχύει ότι 2n^2<<n^3, άρα TA(n)<<TB(n).



#### **Άσκηση 4**

	

	Μεταξύ των 2 αλγορίθμων Α και Β θα επέλεγα τον Α, καθώς σε κάθε περίπτωση τόσο η καλύτερη, όσο και η μέση χρονική πολυπλοκότητα είναι n\*logn, που είναι πολύ πιο γρήγορη από την μέση χρονική πολυπλοκότητα του Β, δηλαδή n^2.



#### **Άσκηση 5**

	

	Η πολυπλοκότητα της συνάρτησης υπολογίζεται ως εξής: 

&nbsp;	Σύμφωνα με το Master Theorem, προκύπτει ότι a=1,b=4 και c=4, συνεπώς logb(a)=log4(1)=0<c

&nbsp;	Επειδή ισχύει ότι c>logb(a), η χρονική πολυπλοκότητα είναι 0(n^c)=0(n^4)

